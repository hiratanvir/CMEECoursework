schoolfield_model <- log((B0*exp((-E/k)*((1/x)-(1/283.15)))) / (1 + (exp((El/k)*((1/Tl)-(1/x)))) + (exp((Eh/k)*((1/Th)-(1/x))))))
temp <- data.frame(x_points, schoolfield_model)
return(temp)
}
#function returns a dataframe with with x values and expected y values when using the schoolfield model
schoolfield <- function(i, schoolfield_df, DF){
sfdf = subset(schoolfield_df, ID == i)
DF2 = subset(DF, uniqueID == i)
x_vals <- DF2$Temp.kel.
#y_vals <- DF$log_TraitValues
if(sfdf$status =="C"){
#parameter values for the cubic model
B0 <- sfdf$B0
E <- sfdf$E
Eh <- sfdf$Eh
El <- sfdf$El
Th <- sfdf$Th
Tl <- sfdf$Tl
# Define k, Boltzmann constant
k = 8.6173303e-05
#get a large number of equidistant points between the actual x points
x_points = seq(min(x_vals),max(x_vals),0.2)
#get the corresponding y_values from the sampled x_points using the model equation
schoolfield_model <- log((B0*exp((-E/k)*((1/x)-(1/283.15)))) / (1 + (exp((El/k)*((1/Tl)-(1/x)))) + (exp((Eh/k)*((1/Th)-(1/x))))))
temp <- data.frame(x_points, schoolfield_model)
return(temp)
}
else{
print("Model did not converge..")
}
}
schoolfield(4, sfdf, DF)
#function returns a dataframe with with x values and expected y values when using the schoolfield model
schoolfield <- function(i, sfdf, DF){
sfdf = subset(schoolfield_df, ID == i)
DF2 = subset(DF, uniqueID == i)
x_vals <- DF2$Temp.kel.
#y_vals <- DF$log_TraitValues
if(sfdf$status =="C"){
#parameter values for the cubic model
B0 <- sfdf$B0
E <- sfdf$E
Eh <- sfdf$Eh
El <- sfdf$El
Th <- sfdf$Th
Tl <- sfdf$Tl
# Define k, Boltzmann constant
k = 8.6173303e-05
#get a large number of equidistant points between the actual x points
x_points = seq(min(x_vals),max(x_vals),0.2)
#get the corresponding y_values from the sampled x_points using the model equation
schoolfield_model <- log((B0*exp((-E/k)*((1/x)-(1/283.15)))) / (1 + (exp((El/k)*((1/Tl)-(1/x)))) + (exp((Eh/k)*((1/Th)-(1/x))))))
temp <- data.frame(x_points, schoolfield_model)
return(temp)
}
else{
print("Model did not converge..")
}
}
schoolfield(4, sfdf, DF)
#!/usr/bin/env Rscript
rm(list=ls())
graphics.off()
require(ggplot2)
library(dplyr)
#load in TPC data set to get the x and y co-ordinates per group
df <- read.csv("../Results/final_dF.csv")
DF = df %>% group_by(uniqueID) %>% arrange(uniqueID) #orders the ID in ascending order
#load in the nlls results for the cubic model and plot the results using ggplot2
cubic_df <- read.csv("../Results/cubic_report.csv") #dataframe is already ordered by ID
#load in the nlls results for the full schoolfield model and plot the results on the same ggplot2 graph
schoolfield_df <- read.csv("../Results/schoolfield_report.csv")
#function returns a dataframe with with x values and expected y values when using the cubic model
cubic <- function(i, cubic_df, DF){
cdf = subset(cubic_df, ID == i)
DF2 = subset(DF, uniqueID == i)
x_vals <- DF2$Temp.kel.
#y_vals <- DF$log_TraitValues
if(cdf$status =="C"){
#parameter values for the cubic model
A1 <- cdf$A
B1 <- cdf$B
C1 <- cdf$C
D1 <- cdf$D
#get a large number of equidistant points between the actual x points
x_points = seq(min(x_vals),max(x_vals),0.2)
#get the corresponding y_values from the sampled x_points using the model equation
cubic_model <- A1 + B1*x_points + C1*x_points^2 + D1*x_points^3
temp <- data.frame(x_points, cubic_model)
return(temp)
}
else{
print("Model did not converge..")
}
}
cubic(4, cubic_df, DF)
#function returns a dataframe with with x values and expected y values when using the schoolfield model
schoolfield <- function(i, schoolfield_df, DF){
sfdf = subset(schoolfield_df, ID == i)
DF2 = subset(DF, uniqueID == i)
x_vals <- DF2$Temp.kel.
#y_vals <- DF$log_TraitValues
if(sfdf$status =="C"){
#parameter values for the cubic model
B0 <- sfdf$B0
E <- sfdf$E
Eh <- sfdf$Eh
El <- sfdf$El
Th <- sfdf$Th
Tl <- sfdf$Tl
# Define k, Boltzmann constant
k = 8.6173303e-05
#get a large number of equidistant points between the actual x points
x_points = seq(min(x_vals),max(x_vals),0.2)
#get the corresponding y_values from the sampled x_points using the model equation
schoolfield_model <- log((B0*exp((-E/k)*((1/x)-(1/283.15)))) / (1 + (exp((El/k)*((1/Tl)-(1/x)))) + (exp((Eh/k)*((1/Th)-(1/x))))))
temp <- data.frame(x_points, schoolfield_model)
return(temp)
}
else{
print("Model did not converge..")
}
}
schoolfield(4, schoolfield_df, DF)
schoolfield(1, schoolfield_df, DF)
#function returns a dataframe with with x values and expected y values when using the schoolfield model
schoolfield <- function(i, schoolfield_df, DF){
sfdf = subset(schoolfield_df, ID == i)
DF2 = subset(DF, uniqueID == i)
x_vals <- DF2$Temp.kel.
#y_vals <- DF$log_TraitValues
if(sfdf$status =="C"){
#parameter values for the cubic model
B0 <- sfdf$B0
E <- sfdf$E
Eh <- sfdf$Eh
El <- sfdf$El
Th <- sfdf$Th
Tl <- sfdf$Tl
# Define k, Boltzmann constant
k = 8.6173303e-05
#get a large number of equidistant points between the actual x points
x_points = seq(min(x_vals),max(x_vals),0.2)
#get the corresponding y_values from the sampled x_points using the model equation
schoolfield_model <- log((B0*exp((-E/k)*((1/x_points)-(1/283.15)))) / (1 + (exp((El/k)*((1/Tl)-(1/x_points)))) + (exp((Eh/k)*((1/Th)-(1/x_points))))))
temp <- data.frame(x_points, schoolfield_model)
return(temp)
}
else{
print("Model did not converge..")
}
}
schoolfield(1, schoolfield_df, DF)
pdf("../Results/nlls_plot.pdf")
for(i in unique(DF$uniqueID)[1:5]){
DF2 = subset(DF, uniqueID == i)
x_vals = DF2$Temp.kel.
y_vals = DF2$log_TraitValues
x = (cubic(i, cubic_df, DF)[1])
y = (cubic(i, cubic_df, DF)[2])
x2 = (schoolfield(i, schoolfield_df, DF)[1])
y2 = (schoolfield(i, schoolfield_df, DF)[2])
models_plot <- ggplot(DF2, aes(x=x_vals, y=y_vals, colour))+geom_point(color="blue")+
xlab("Temp(kelvin)")+
ylab("Log Trait Value")+
ggtitle(paste("Model plots for ID:",i))+
theme(plot.title = element_text(hjust = 0.5)) + geom_line(data=cubic(i, cubic_df, DF), aes(x, y, colour="Cubic model"))+
geom_line(data=schoolfield(i, schoolfield_df, DF), aes(x2, y2, colour="Schoolfield model"))
models_plot <- models_plot + labs(color='Legend')
print(models_plot)
}
for(i in unique(DF$uniqueID)[1:5]){
DF2 = subset(DF, uniqueID == i)
x_vals = DF2$Temp.kel.
y_vals = DF2$log_TraitValues
x = (cubic(i, cubic_df, DF)[1])
y = (cubic(i, cubic_df, DF)[2])
x2 = (schoolfield(i, schoolfield_df, DF)[1])
y2 = (schoolfield(i, schoolfield_df, DF)[2])
models_plot <- ggplot(DF2, aes(x=x_vals, y=y_vals, colour))+geom_point(color="blue")+
xlab("Temp(kelvin)")+
ylab("Log Trait Value")+
ggtitle(paste("Model plots for ID:",i))+
theme(plot.title = element_text(hjust = 0.5)) + geom_line(data=cubic(i, cubic_df, DF), aes(x, y, colour="Cubic model"))+
geom_line(data=schoolfield(i, schoolfield_df, DF), aes(x=x2, y=y2, colour="Schoolfield model"))
models_plot <- models_plot + labs(color='Legend')
print(models_plot)
}
print(models_plot)
print(models_plot)
for(i in unique(DF$uniqueID)[1:5]){
DF2 = subset(DF, uniqueID == i)
x_vals = DF2$Temp.kel.
y_vals = DF2$log_TraitValues
x = (cubic(i, cubic_df, DF)[1])
y = (cubic(i, cubic_df, DF)[2])
x2 = (schoolfield(i, schoolfield_df, DF)[1])
y2 = (schoolfield(i, schoolfield_df, DF)[2])
models_plot <- ggplot(DF2, aes(x=x_vals, y=y_vals, colour))+geom_point(color="blue")+
xlab("Temp(kelvin)")+
ylab("Log Trait Value")+
ggtitle(paste("Model plots for ID:",i))+
theme(plot.title = element_text(hjust = 0.5)) + geom_line(data=cubic(i, cubic_df, DF), aes(x, y, colour="Cubic model"))+
geom_line(data=schoolfield(i, schoolfield_df, DF), aes(x2, y2, colour="Schoolfield model"))
models_plot <- models_plot + labs(color='Legend')
print(models_plot)
}
rep(0, 100)
for(i in unique(DF$uniqueID)[1:5]){
sfdf = subset(schoolfield_df, ID == i)
DF2 = subset(DF, uniqueID == i)
x_vals = DF2$Temp.kel.
y_vals = DF2$log_TraitValues
x = (cubic(i, cubic_df, DF)[1])
y = (cubic(i, cubic_df, DF)[2])
if(sfdf$status =="C"){
x2 = (schoolfield(i, schoolfield_df, DF)[1])
y2 = (schoolfield(i, schoolfield_df, DF)[2])
}
else{
x2 = rep(0, 100)
y2 = rep(0, 100)
}
models_plot <- ggplot(DF2, aes(x=x_vals, y=y_vals, colour))+geom_point(color="blue")+
xlab("Temp(kelvin)")+
ylab("Log Trait Value")+
ggtitle(paste("Model plots for ID:",i))+
theme(plot.title = element_text(hjust = 0.5)) + geom_line(data=cubic(i, cubic_df, DF), aes(x, y, colour="Cubic model"))+
geom_line(data=schoolfield(i, schoolfield_df, DF), aes(x2, y2, colour="Schoolfield model"))
models_plot <- models_plot + labs(color='Legend')
print(models_plot)
}
#!/usr/bin/env Rscript
rm(list=ls())
graphics.off()
require(ggplot2)
library(dplyr)
#load in TPC data set to get the x and y co-ordinates per group
df <- read.csv("../Results/final_dF.csv")
DF = df %>% group_by(uniqueID) %>% arrange(uniqueID) #orders the ID in ascending order
#load in the nlls results for the cubic model and plot the results using ggplot2
cubic_df <- read.csv("../Results/cubic_report.csv") #dataframe is already ordered by ID
#load in the nlls results for the full schoolfield model and plot the results on the same ggplot2 graph
schoolfield_df <- read.csv("../Results/schoolfield_report.csv")
#function returns a dataframe with with x values and expected y values when using the cubic model
cubic <- function(i, cubic_df, DF){
cdf = subset(cubic_df, ID == i)
DF2 = subset(DF, uniqueID == i)
x_vals <- DF2$Temp.kel.
#y_vals <- DF$log_TraitValues
if(cdf$status =="C"){
#parameter values for the cubic model
A1 <- cdf$A
B1 <- cdf$B
C1 <- cdf$C
D1 <- cdf$D
#get a large number of equidistant points between the actual x points
x_points = seq(min(x_vals),max(x_vals),0.2)
#get the corresponding y_values from the sampled x_points using the model equation
cubic_model <- A1 + B1*x_points + C1*x_points^2 + D1*x_points^3
temp <- data.frame(x_points, cubic_model)
return(temp)
}
else{
print("Model did not converge..")
}
}
#function returns a dataframe with with x values and expected y values when using the schoolfield model
schoolfield <- function(i, schoolfield_df, DF){
sfdf = subset(schoolfield_df, ID == i)
DF2 = subset(DF, uniqueID == i)
x_vals <- DF2$Temp.kel.
#y_vals <- DF$log_TraitValues
if(sfdf$status =="C"){
#parameter values for the cubic model
B0 <- sfdf$B0
E <- sfdf$E
Eh <- sfdf$Eh
El <- sfdf$El
Th <- sfdf$Th
Tl <- sfdf$Tl
# Define k, Boltzmann constant
k = 8.6173303e-05
#get a large number of equidistant points between the actual x points
x_points = seq(min(x_vals),max(x_vals),0.2)
#get the corresponding y_values from the sampled x_points using the model equation
schoolfield_model <- log((B0*exp((-E/k)*((1/x_points)-(1/283.15)))) / (1 + (exp((El/k)*((1/Tl)-(1/x_points)))) + (exp((Eh/k)*((1/Th)-(1/x_points))))))
temp <- data.frame(x_points, schoolfield_model)
return(temp)
}
else{
print("Model did not converge..")
}
}
pdf("../Results/nlls_plot.pdf")
for(i in unique(DF$uniqueID)[1:5]){
sfdf = subset(schoolfield_df, ID == i)
DF2 = subset(DF, uniqueID == i)
x_vals = DF2$Temp.kel.
y_vals = DF2$log_TraitValues
x = (cubic(i, cubic_df, DF)[1])
y = (cubic(i, cubic_df, DF)[2])
if(sfdf$status =="C"){
x2 = (schoolfield(i, schoolfield_df, DF)[1])
y2 = (schoolfield(i, schoolfield_df, DF)[2])
}
else{
x2 = rep(0, 100)
y2 = rep(0, 100)
}
models_plot <- ggplot(DF2, aes(x=x_vals, y=y_vals, colour))+geom_point(color="blue")+
xlab("Temp(kelvin)")+
ylab("Log Trait Value")+
ggtitle(paste("Model plots for ID:",i))+
theme(plot.title = element_text(hjust = 0.5)) + geom_line(data=cubic(i, cubic_df, DF), aes(x, y, colour="Cubic model"))+
geom_line(data=schoolfield(i, schoolfield_df, DF), aes(x2, y2, colour="Schoolfield model"))
models_plot <- models_plot + labs(color='Legend')
print(models_plot)
}
dev.off()
source('~/CMEECoursework/Week8/Code/nlls_plots.r')
source('~/CMEECoursework/Week8/Code/nlls_plots.r')
if(NA){
print(T)
}
if(NA == TRUE){
print(T)
}
if(NaN == TRUE){
print(T)
}
if(c(NaN) == TRUE){
print(T)
}
if(NULL){
print(T)
}
if(NULL == TRUE){
print(T)
}
NULL
NULL == T
NULL == T
NULL == F
is.null(NULL)
!is.null(NULL)
isTRUE(x)
isTRUE(df)
source('~/CMEECoursework/Week8/Code/nlls_plots.r')
schoolout
source('~/CMEECoursework/Week8/Code/nlls_plots.r')
source('~/CMEECoursework/Week8/Code/nlls_plots.r')
source('~/CMEECoursework/Week8/Code/nlls_plots.r')
source('~/CMEECoursework/Week8/Code/nlls_plots.r')
install.packages("gridExtra")
library(grid)
library(gridExtra)
source('~/CMEECoursework/Week8/Code/nlls_plots.r')
source('~/CMEECoursework/Week8/Code/nlls_plots.r')
source('~/CMEECoursework/Week8/Code/nlls_plots.r')
source('~/CMEECoursework/Week8/Code/nlls_plots.r')
source('~/CMEECoursework/Week8/Code/nlls_plots.r')
#load in TPC data set to get the x and y co-ordinates per group
df <- read.csv("../Results/FINAL_dF.csv")
source('~/CMEECoursework/Week8/Code/nlls_plots.r')
View(DF)
View(DF)
View(schoolfield_df)
View(cubic_df)
View(sfdf)
source('~/CMEECoursework/Week8/Code/nlls_plots.r')
source('~/CMEECoursework/Week8/Code/nlls_plots.r')
View(cubeout)
View(schoolout)
View(DF)
View(x2)
View(y)
View(x)
View(y2)
View(cubic_df)
View(schoolfield_df)
source('~/CMEECoursework/Week8/Code/nlls_plots.r')
source('~/CMEECoursework/Week8/Code/nlls_plots.r')
source('~/CMEECoursework/Week8/Code/nlls_plots.r')
()
View(cubeout)
source('~/CMEECoursework/Week8/Code/nlls_plots.r')
source('~/CMEECoursework/Week8/Code/nlls_plots.r')
View(cubeout)
View(schoolout)
exp(-1.22)
source('~/CMEECoursework/Week8/Code/nlls_plots.r')
View(cubic_df)
source('~/CMEECoursework/Week8/Code/nlls_plots.r')
cubic_model
source('~/CMEECoursework/Week8/Code/nlls_plots.r')
source('~/CMEECoursework/Week8/Code/nlls_plots.r')
source('~/CMEECoursework/Week8/Code/nlls_plots.r')
source('~/CMEECoursework/Week8/Code/nlls_plots.r')
source('~/CMEECoursework/Week8/Code/nlls_plots.r')
#The AIC differences in the cubic model
AIC_min = min(cubic_df$AIC)
AIC_min
for(i in unique(cubic_df$ID)){
cubic_df$AIC_difference <- cubic_df$AIC - AIC_min
}
AIC_sfmin = min(schoolfield_df$AIC)
AIC_sfmin
View(schoolfield_df)
AIC_sfmin = min(schoolfield_df$AIC, na.rm=True)
AIC_sfmin = min((schoolfield_df$AIC) na.rm=True)
AIC_sfmin = min((schoolfield_df$AIC), na.rm=True)
AIC_sfmin = min(schoolfield_df$AIC, na.rm=T)
AIC_sfmin
#The AIC differences in the cubic model
AIC_min = min(cubic_df$AIC$ID)
for(i in unique(schoolfield_df$ID)){
AIC_difference = schoolfield_df$AIC - AIC_min
}
View(schoolfield_df)
for(i in unique(schoolfield_df$ID)){
schoolfield_df$AIC_difference = schoolfield_df$AIC - AIC_min
}
subset_cubic <- subset(cubic_df$ID,cubic_df$AIC)
subset_cubic <- subset(cubic_df$ID+cubic_df$AIC)
subset_cubic <- subset(cubic_df, colnames(ID, AIC))
subset_cubic <- subset(cubic_df, colnames('ID', 'AIC'))
subset_cubic <- subset(cubic_df, colnames=(ID,AIC))
subset_cubic <- cubic_df[,c("ID","AIC")]
View(subset_cubic)
subset_sf <- schoolfield_df[,c("ID","AIC")]
View(subset_sf)
#merge the two subsetted dataframes by id
aic_df <- merge(x = subset_cubic, y = subset_sf, by = "ID", all = TRUE)
View(aic_df)
View(aic_df)
colnames(aic_df) <- c("ID","AIC_cubic","AIC_schoolfield")
apply(aic_df, 1, FUN=min)
apply(aic_df, 1, FUN=max)
for(i in unique(aic_df$ID)){
aic_min = apply(aic_df, 1, FUN=min)
aic_max = apply(aic_df, 1, FUN=max)
aic_df$AIC_difference <- aic_max - aic_min
}
aic_max = apply(aic_df, 1, FUN=max)
aic_max
library(matrixStats)
install.packages("matrixStats")
library(matrixStats)
?matrixStats
rowMaxs(as.matrix(aic_df))
#!/usr/bin/env Rscript
rm(list=ls())
graphics.off()
#load in TPC data set to get the x and y co-ordinates per group
df <- read.csv("../Results/FINAL_dF.csv")
DF = df %>% group_by(uniqueID) %>% arrange(uniqueID) #orders the ID in ascending order
#load in the nlls results for the cubic model and plot the results using ggplot2
cubic_df <- read.csv("../Results/cubic_report.csv") #dataframe is already ordered by ID
#load in the nlls results for the full schoolfield model and plot the results on the same ggplot2 graph
schoolfield_df <- read.csv("../Results/schoolfield_report.csv")
#make new dataframe containing ID column and AIC for cubic and schoolfield
subset_cubic <- cubic_df[,c("ID","AIC")]
subset_sf <- schoolfield_df[,c("ID","AIC")]
#merge the two subsetted dataframes by id
aic_df <- merge(x = subset_cubic, y = subset_sf, by = "ID", all = TRUE)
colnames(aic_df) <- c("ID","AIC_cubic","AIC_schoolfield")
View(aic_df)
apply(aic_df, 1, FUN=max)
library(matrixStats)
rowMaxs(as.matrix(aic_df))
apply(aic_df[2:3], 1, FUN=max)
(aic_df[2:3], 1, FUN=min)
(aic_df[2:3], 1, FUN=min)
aic_df[2:3]
apply((aic_df[2:3]), 1, FUN=min)
apply((aic_df[2:3]), 1, FUN=max)
for(i in unique(aic_df$ID)){
aic_min = apply((aic_df[2:3]), 1, FUN=min)
aic_max = apply((aic_df[2:3]), 1, FUN=max)
aic_df$AIC_difference <- aic_max - aic_min
}
for(i in unique(aic_df$ID)){
aic_min = apply((aic_df[2:3]), 1, FUN=min)
aic_max = apply((aic_df[2:3]), 1, FUN=max)
aic_df$AIC_diff_cubic <- aic_df$AIC_cubic - aic_min
aic_df$AIC_diff_sf <- aic_df$AIC_schoolfield - aic_min
}
#!/usr/bin/env Rscript
rm(list=ls())
graphics.off()
require(ggplot2)
library(dplyr)
#load in TPC data set to get the x and y co-ordinates per group
df <- read.csv("../Results/FINAL_dF.csv")
DF = df %>% group_by(uniqueID) %>% arrange(uniqueID) #orders the ID in ascending order
#load in the nlls results for the cubic model and plot the results using ggplot2
cubic_df <- read.csv("../Results/cubic_report.csv") #dataframe is already ordered by ID
#load in the nlls results for the full schoolfield model and plot the results on the same ggplot2 graph
schoolfield_df <- read.csv("../Results/schoolfield_report.csv")
#make new dataframe containing ID column and AIC for cubic and schoolfield
subset_cubic <- cubic_df[,c("ID","AIC")]
subset_sf <- schoolfield_df[,c("ID","AIC")]
#merge the two subsetted dataframes by id
aic_df <- merge(x = subset_cubic, y = subset_sf, by = "ID", all = TRUE)
colnames(aic_df) <- c("ID","AIC_cubic","AIC_schoolfield")
for(i in unique(aic_df$ID)){
aic_min = apply((aic_df[2:3]), 1, FUN=min)
aic_max = apply((aic_df[2:3]), 1, FUN=max)
aic_df$AIC_diff_cubic <- aic_df$AIC_cubic - aic_min
aic_df$AIC_diff_sf <- aic_df$AIC_schoolfield - aic_min
}
