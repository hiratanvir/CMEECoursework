Nt <- RO*ncol(population[[1]])/(1+(ncol(population[[1]])/M))
for (i in 2:(t+1))
{
# THE ALLELE CONFIG AT THE NEXT GEN
# FIRST WAY OF SAMPLING
population[[i]]<-matrix(sample(0:1, size=Nt, prob=c(allele.freq[i-1], 1-allele.freq[i-1]), replace=TRUE),
nr=2)
# ANOTHER WAY OF SAMPLING
#population[[i]]<-matrix(
#		sample(population[[i-1]], size=2*N, replace=TRUE),
#	nr=2)
# THE ALLELE FREQ AT THE NEXT GEN
allele.freq[i]<-sum(population[[i]]==0)/(2*N)
Nt <- RO*ncol(population[[i]])/(1+(ncol(population[[i]])/M))
}
}
# PUT ALL YOUR OUTPUTS INTO ANOTHER LIST AND THEN RETURN THEM
return(list(population=population, allele.freq=allele.freq))
#####
# TEST RUN
sim.genetic.drift(p=0.5, t=4, N=10, d=0.6, RO=2, M=10)
Nt
Nt <- floor(RO*ncol(population[[1]])/(1+(ncol(population[[1]])/M)))
source('~/Documents/Evolutionary_modelling/WF_simulation.r')
################################################
# SIMULATE GENETIC DRIFT
# FORWARD IN TIME
# ONE LOCUS, TWO ALLELES
################################################
sim.genetic.drift<-function(p=0.5, t=10, N=50, d=0.6, RO=2, M=10)
{
# DEFINITIONS TO THE INPUT ARGUMENTS
# p IS THE ALLELE FREQ FOR THE FIRST ALLELE (ALLELE 0)
# t IS THE NUMBER OF GENERATIONS
# N IS THE EFFECTIVE POPULATION SIZE
# DEFINE OUTPUTS
# 1) THE ALLELE CONFIG FOR THE ENTIRE POPULATION OVER TIME
# REPORT AS A LIST
population<-list()
length(population)<-t+1
# OPTIONAL, TO GIVE NAMES TO EVERY ELEMENTS OF population
names(population)<-rep(NA, t+1)
for (i in 1:length(population))
{names(population)[i]<-paste(c('generation', i-1), collapse='')}
# 2) I WOULD ALSO LIKE TO RETURN THE ALLELE FREQ OVER TIME
# AS A VECTOR
allele.freq<-rep(NA, t+1)
# TO ASSIGN INITIAL ALLELE COUNTS
k<-ceiling(2*N*p)
population[[1]]<-matrix(sample(c(rep(0, k), rep(1, 2*N-k))), nr=2) #initial population
# THE INITIAL ALLELE FREQ
allele.freq[1]<-sum(population[[1]]==0)/(2*N)
# PROPAGATION
#return a list of population showing changes in population size over the generations
#Initialise Nt
#initialise Nt as the new population size at t=0
Nt <- floor(RO*ncol(population[[1]])/(1+(ncol(population[[1]])/M)))
for (i in 2:(t+1))
{
# THE ALLELE CONFIG AT THE NEXT GEN
# FIRST WAY OF SAMPLING
population[[i]]<-matrix(sample(0:1, size=Nt, prob=c(allele.freq[i-1], 1-allele.freq[i-1]), replace=TRUE),
nr=2)
# ANOTHER WAY OF SAMPLING
#population[[i]]<-matrix(
#		sample(population[[i-1]], size=2*N, replace=TRUE),
#	nr=2)
# THE ALLELE FREQ AT THE NEXT GEN
allele.freq[i]<-sum(population[[i]]==0)/(2*N)
Nt <- RO*ncol(population[[i]])/(1+(ncol(population[[i]])/M))
}
# PUT ALL YOUR OUTPUTS INTO ANOTHER LIST AND THEN RETURN THEM
return(list(population=population, allele.freq=allele.freq))
}
#####
# TEST RUN
sim.genetic.drift(p=0.5, t=4, N=10, d=0.6, RO=2, M=10)
#####
# TEST RUN
sim.genetic.drift(p=0.5, t=4, N=10, d=0.6, RO=2, M=10)
#####
# TEST RUN
sim.genetic.drift(p=0.5, t=4, N=10, d=0.6, RO=2, M=10)
#####
# TEST RUN
sim.genetic.drift(p=0.5, t=4, N=10, d=0.6, RO=2, M=10)
################################################
# SIMULATE GENETIC DRIFT
# FORWARD IN TIME
# ONE LOCUS, TWO ALLELES
################################################
sim.genetic.drift<-function(p=0.5, t=10, N=50, d=0.6, RO=2, M=10)
{
# DEFINITIONS TO THE INPUT ARGUMENTS
# p IS THE ALLELE FREQ FOR THE FIRST ALLELE (ALLELE 0)
# t IS THE NUMBER OF GENERATIONS
# N IS THE EFFECTIVE POPULATION SIZE
# DEFINE OUTPUTS
# 1) THE ALLELE CONFIG FOR THE ENTIRE POPULATION OVER TIME
# REPORT AS A LIST
population<-list()
length(population)<-t+1
# OPTIONAL, TO GIVE NAMES TO EVERY ELEMENTS OF population
names(population)<-rep(NA, t+1)
for (i in 1:length(population))
{names(population)[i]<-paste(c('generation', i-1), collapse='')}
# 2) I WOULD ALSO LIKE TO RETURN THE ALLELE FREQ OVER TIME
# AS A VECTOR
allele.freq<-rep(NA, t+1)
# TO ASSIGN INITIAL ALLELE COUNTS
k<-ceiling(2*N*p)
population[[1]]<-matrix(sample(c(rep(0, k), rep(1, 2*N-k))), nr=2) #initial population
# THE INITIAL ALLELE FREQ
allele.freq[1]<-sum(population[[1]]==0)/(2*N)
# PROPAGATION
#return a list of population showing changes in population size over the generations
#Initialise Nt
#initialise Nt as the new population size at t=0
Nt <- floor(RO*ncol(population[[1]])/(1+(ncol(population[[1]])/M)))
for (i in 2:(t+1))
{
# THE ALLELE CONFIG AT THE NEXT GEN
# FIRST WAY OF SAMPLING
population[[i]]<-matrix(sample(0:1, size=Nt, prob=c(allele.freq[i-1], 1-allele.freq[i-1]), replace=TRUE),
nr=2)
# ANOTHER WAY OF SAMPLING
#population[[i]]<-matrix(
#		sample(population[[i-1]], size=2*N, replace=TRUE),
#	nr=2)
# THE ALLELE FREQ AT THE NEXT GEN
allele.freq[i]<-sum(population[[i]]==0)/(Nt)
Nt <- RO*ncol(population[[i]])/(1+(ncol(population[[i]])/M))
}
# PUT ALL YOUR OUTPUTS INTO ANOTHER LIST AND THEN RETURN THEM
return(list(population=population, allele.freq=allele.freq))
}
#####
# TEST RUN
sim.genetic.drift(p=0.5, t=4, N=10, d=0.6, RO=2, M=10)
{
# THE ALLELE CONFIG AT THE NEXT GEN
# FIRST WAY OF SAMPLING
population[[i]]<-matrix(sample(0:1, size=2*Nt, prob=c(allele.freq[i-1], 1-allele.freq[i-1]), replace=TRUE),
nr=2)
# ANOTHER WAY OF SAMPLING
#population[[i]]<-matrix(
#		sample(population[[i-1]], size=2*N, replace=TRUE),
#	nr=2)
# THE ALLELE FREQ AT THE NEXT GEN
allele.freq[i]<-sum(population[[i]]==0)/(2*Nt)
Nt <- RO*ncol(population[[i]])/(1+(ncol(population[[i]])/M))
}
################################################
# SIMULATE GENETIC DRIFT
# FORWARD IN TIME
# ONE LOCUS, TWO ALLELES
################################################
sim.genetic.drift<-function(p=0.5, t=10, N=50, d=0.6, RO=2, M=10)
{
# DEFINITIONS TO THE INPUT ARGUMENTS
# p IS THE ALLELE FREQ FOR THE FIRST ALLELE (ALLELE 0)
# t IS THE NUMBER OF GENERATIONS
# N IS THE EFFECTIVE POPULATION SIZE
# DEFINE OUTPUTS
# 1) THE ALLELE CONFIG FOR THE ENTIRE POPULATION OVER TIME
# REPORT AS A LIST
population<-list()
length(population)<-t+1
# OPTIONAL, TO GIVE NAMES TO EVERY ELEMENTS OF population
names(population)<-rep(NA, t+1)
for (i in 1:length(population))
{names(population)[i]<-paste(c('generation', i-1), collapse='')}
# 2) I WOULD ALSO LIKE TO RETURN THE ALLELE FREQ OVER TIME
# AS A VECTOR
allele.freq<-rep(NA, t+1)
# TO ASSIGN INITIAL ALLELE COUNTS
k<-ceiling(2*N*p)
population[[1]]<-matrix(sample(c(rep(0, k), rep(1, 2*N-k))), nr=2) #initial population
# THE INITIAL ALLELE FREQ
allele.freq[1]<-sum(population[[1]]==0)/(2*N)
# PROPAGATION
#return a list of population showing changes in population size over the generations
#Initialise Nt
#initialise Nt as the new population size at t=0
Nt <- floor(RO*ncol(population[[1]])/(1+(ncol(population[[1]])/M)))
for (i in 2:(t+1))
{
# THE ALLELE CONFIG AT THE NEXT GEN
# FIRST WAY OF SAMPLING
population[[i]]<-matrix(sample(0:1, size=2*Nt, prob=c(allele.freq[i-1], 1-allele.freq[i-1]), replace=TRUE),
nr=2)
# ANOTHER WAY OF SAMPLING
#population[[i]]<-matrix(
#		sample(population[[i-1]], size=2*N, replace=TRUE),
#	nr=2)
# THE ALLELE FREQ AT THE NEXT GEN
allele.freq[i]<-sum(population[[i]]==0)/(2*Nt)
Nt <- RO*ncol(population[[i]])/(1+(ncol(population[[i]])/M))
}
# PUT ALL YOUR OUTPUTS INTO ANOTHER LIST AND THEN RETURN THEM
return(list(population=population, allele.freq=allele.freq))
}
#####
# TEST RUN
sim.genetic.drift(p=0.5, t=4, N=10, d=0.6, RO=2, M=10)
k
citation()
install.packages("installr")
install.packages("instaR")
getwd()
setwd('CMEECoursework/CMEEProject/Code/')
source('~/CMEECoursework/CMEEProject/Code/TempCorrBacteria.r')
View(GR_HighTemp)
View(unique_ids)
source('~/CMEECoursework/CMEEProject/Code/TempCorrArchaea.r')
View(schoolfield_DF)
View(unique_ids)
View(schoolfield_DF)
View(MidTemp)
View(merged_GR)
View(merged_DF)
View(LowTemp)
source('~/CMEECoursework/CMEEProject/Code/TempCorrBacteria.r')
View(unique_ids)
View(schoolfield_DF)
na.omit(schoolfield_DF)
source('~/CMEECoursework/CMEEProject/Code/TempCorrArchaea.r')
na.omit(schoolfield_DF)
source('~/CMEECoursework/CMEEProject/Code/TempCorrBacteria.r')
sum(schoolfield_DF)
?summarise
table(schoolfield_DF$status)
source('~/CMEECoursework/CMEEProject/Code/TempCorrArchaea.r')
table(schoolfield_DF$status)
source('~/CMEECoursework/CMEEProject/Code/TempCorrPhytoplankton.r')
table(schoolfield_DF$status)
rm(list=ls())
getwd()
source('~/CMEECoursework/CMEEProject/Code/TempCorrArchaea.r')
View(LowTemp)
View(GR_LowTemp)
View(unique_ids)
View(LT)
View(merged_DF)
View(merged_DF)
View(Average_volumes)
source('~/CMEECoursework/CMEEProject/Code/bacteria_plots.r')
source('~/CMEECoursework/CMEEProject/Code/TempCorrBacteria.r')
View(unique_ids)
View(schoolfield_DF)
View(schoolfield_df)
View(Average_volumes)
#averaging growth rates for repeated species to get single data point
unique_gr <- unique_ids %>%
group_by(GenusSpecies) %>%
summarise(Mean = mean(value, na.rm = T))
#averaging growth rates for repeated species to get single data point
unique_gr <- unique_ids %>%
group_by(GenusSpecies) %>%
summarise(Mean = mean(LowTemp_GR, MidTemp_GR, HighTemp_GR, na.rm = T))
#averaging growth rates for repeated species to get single data point
unique_gr <- unique_ids %>%
group_by(GenusSpecies) %>%
summarise_at(vars("LowTemp_GR", "MidTemp_GR", "HighTemp_GR"), mean, na.rm = T))
#averaging growth rates for repeated species to get single data point
unique_gr <- unique_ids %>%
group_by(GenusSpecies) %>%
summarise_at(vars("LowTemp_GR", "MidTemp_GR", "HighTemp_GR"), mean)
View(unique_gr)
#averaging growth rates for repeated species to get single data point
unique_gr <- unique_ids %>%
group_by(GenusSpecies) %>%
summarise_at(vars("LowTemp_GR", "MidTemp_GR", "HighTemp_GR"), mean, na.rm=T)
View(unique_gr)
LowTemp <- unique_gr[,c("AverageVolume","LowTemp_GR")]
LowTemp <- na.omit(LowTemp)
View(Average_volumes)
unique_species <- Average_volumes[ !duplicated(Average_volumes[ , 1] ) , ]
View(unique_species)
unique_species <- Average_volumes[ !duplicated(Average_volumes[ , 2] ) , ]
View(unique_species)
unique_data <- inner_join(unique_species, unique_gr, by='GenusSpecies')
View(unique_data)
LowTemp <- unique_data[,c("AverageVolume","LowTemp_GR")]
LowTemp <- na.omit(LowTemp)
View(LowTemp)
LowTemp <- unique_data[,c("GenusSpecies","AverageVolume","LowTemp_GR")]
LowTemp <- na.omit(LowTemp)
MidTemp <- unique_gr[,c("GenusSpecies","AverageVolume","MidTemp_GR")]
MidTemp <- na.omit(MidTemp)
MidTemp <- unique_data[,c("GenusSpecies","AverageVolume","MidTemp_GR")]
MidTemp <- na.omit(MidTemp)
View(MidTemp)
HighTemp <- unique_data[,c("GenusSpecies","AverageVolume","HighTemp_GR")]
HighTemp <- na.omit(HighTemp)
View(HighTemp)
source('~/CMEECoursework/CMEEProject/Code/TempCorrBacteria.r')
View(unique_ids)
cols <- c("MinVolume","MaxVolume","AverageVolume")
unique_data[cols] <- log10(unique_data[cols])
source('~/CMEECoursework/CMEEProject/Code/TempCorrBacteria.r')
View(merged_DF)
#!/usr/bin/env Rscript
rm(list=ls())
graphics.off()
require(ggplot2)
library(dplyr)
library(ggpmisc)
library(grid)
library(gridExtra)
#load in TPC data set to get the x and y co-ordinates per group
df <- read.csv("../Data/bacteria_subset.csv")
DF = df %>% group_by(uniqueID) %>% arrange(uniqueID) #orders the ID in ascending order
#load in the nlls results for the full schoolfield model and plot the results on the same ggplot2 graph
schoolfield_DF <- read.csv("../Results/bacteria_schoolfield_params.csv")
#read in temperature ranges for IDs
temp_range <- read.csv("../Data/temperature_data.csv")
schoolfield_df <- merge(schoolfield_DF, temp_range, by="ID")
#function returns a dataframe with with x values and expected y values when using the schoolfield model
temp_correct <- function(sfdf, temp){
temp_df <- data.frame(ID=NA, GR=NA)
for(i in 1:nrow(sfdf)){
if(sfdf[i,"status"] =="C"){
#parameter values for the Schoolfield model
B0 <- sfdf[i,"B0"]
E <- sfdf[i,"E"]
Eh <- sfdf[i,"Eh"]
El <- sfdf[i,"El"]
Th <- sfdf[i,"Th"]
Tl <- sfdf[i,"Tl"]
# Define k, Boltzmann constant
k = 8.6173303e-05
#if (temp < min_temp || temp > max_temp) {d_f = NA}
x_points = temp
#Defining minimum and maximum temperature
Min <- temp_range[i,"MinTemp"]
Max <- temp_range[i,"MaxTemp"]
if(x_points >= Min & x_points <= Max){
#get the corresponding y_values from the sampled x_points using the model equation
schoolfield_model <- ((B0*exp((-E/k)*((1/x_points)-(1/283.15)))) / (1 + (exp((El/k)*((1/Tl)-(1/x_points)))) + (exp((Eh/k)*((1/Th)-(1/x_points))))))
} else{
schoolfield_model <- NA
}
d_f <- data.frame(ID=sfdf[i, "ID"], GR=schoolfield_model)
}
else{
d_f <- data.frame(ID=sfdf[i, "ID"], GR=NA)
}
temp_df <- rbind(temp_df, d_f)
}
return(temp_df)
}
#initialising empty dataframe to append growth rates at temperature = 279.3598 Kelvin
GR_LowTemp <- data.frame(matrix(ncol = 2, nrow = 0))
GR_LowTemp <- rbind(GR_LowTemp, temp_correct(schoolfield_df, 279.3598))
x <- c("uniqueID", "LowTemp_GR")
colnames(GR_LowTemp) <- x
#initialising empty dataframe to append growth rates at temperature = 289.15 Kelvin
GR_MidTemp <- data.frame(matrix(ncol = 2, nrow = 0))
GR_MidTemp <- rbind(GR_MidTemp, temp_correct(schoolfield_df, 289.15))
x <- c("uniqueID", "MidTemp_GR")
colnames(GR_MidTemp) <- x
#initialising empty dataframe to append growth rates at temperature = 310 Kelvin
GR_HighTemp <- data.frame(matrix(ncol = 2, nrow = 0))
GR_HighTemp <- rbind(GR_HighTemp, temp_correct(schoolfield_df, 305.9856))
x <- c("uniqueID", "HighTemp_GR")
colnames(GR_HighTemp) <- x
#Joining only two dataframes together using dplyr
#merged <- inner_join(GR_LowTemp, GR_MidTemp, by='ID')
#Joining more than two dataframes together using dplyr
merged_GR <- inner_join(GR_LowTemp, GR_MidTemp, by='uniqueID') %>%
inner_join(., GR_HighTemp, by='uniqueID')
Average_volumes <- DF[,c("uniqueID","GenusSpecies","MinVolume","MaxVolume","AverageVolume","VolumeUnit")]
####### LOG TRANSFORMING THE GROWTH RATES and VOLUMES ######################################################################
# Y= Y0.M^a
# ln(Y) = Y0 + a.ln(M) + E
#Merge dataframe on ID to combine data for volume and growth rate
merged_DF <- inner_join(Average_volumes, merged_GR, by='uniqueID')
#Drop repeated IDs
unique_ids <- merged_DF[ !duplicated(merged_DF[ , 1] ) , ]
#averaging growth rates for repeated species to get single data point
unique_gr <- unique_ids %>%
group_by(GenusSpecies) %>%
summarise_at(vars("LowTemp_GR", "MidTemp_GR", "HighTemp_GR"), mean, na.rm=T)
View(unique_gr)
View(unique_ids)
unique_species <- Average_volumes[ !duplicated(Average_volumes[ , 2] ) , ]
unique_data <- inner_join(unique_species, unique_gr, by='GenusSpecies')
View(unique_data)
#Subsetting columns which are going to be log-transformed
cols <- c("MinVolume","MaxVolume","AverageVolume","LowTemp_GR","MidTemp_GR","HighTemp_GR")
unique_data[cols] <- log10(unique_data[cols])
LowTemp <- unique_data[,c("GenusSpecies","AverageVolume","LowTemp_GR")]
LowTemp <- na.omit(LowTemp)
MidTemp <- unique_data[,c("GenusSpecies","AverageVolume","MidTemp_GR")]
MidTemp <- na.omit(MidTemp)
HighTemp <- unique_data[,c("GenusSpecies","AverageVolume","HighTemp_GR")]
HighTemp <- na.omit(HighTemp)
source('~/CMEECoursework/CMEEProject/Code/TempCorrBacteria.r')
#!/usr/bin/env Rscript
rm(list=ls())
graphics.off()
require(ggplot2)
library(dplyr)
library(ggpmisc)
library(grid)
library(gridExtra)
#load in TPC data set to get the x and y co-ordinates per group
df <- read.csv("../Data/phytoplankton_subset.csv")
DF = df %>% group_by(uniqueID) %>% arrange(uniqueID) #orders the ID in ascending order
#load in the nlls results for the full schoolfield model and plot the results on the same ggplot2 graph
schoolfield_DF <- read.csv("../Results/phytoplankton_schoolfield_params.csv")
#read in temperature ranges for IDs
temp_range <- read.csv("../Data/temperature_data_phytoplankton.csv")
schoolfield_df <- merge(schoolfield_DF, temp_range, by="ID")
#function returns a dataframe with with x values and expected y values when using the schoolfield model
temp_correct <- function(sfdf, temp){
temp_df <- data.frame(ID=NA, GR=NA)
for(i in 1:nrow(sfdf)){
if(sfdf[i,"status"] =="C"){
#parameter values for the Schoolfield model
B0 <- sfdf[i,"B0"]
E <- sfdf[i,"E"]
Eh <- sfdf[i,"Eh"]
El <- sfdf[i,"El"]
Th <- sfdf[i,"Th"]
Tl <- sfdf[i,"Tl"]
# Define k, Boltzmann constant
k = 8.6173303e-05
x_points = temp
#Defining minimum and maximum temperature
Min <- temp_range[i,"MinTemp"]
Max <- temp_range[i,"MaxTemp"]
if(x_points >= Min & x_points <= Max){
#get the corresponding y_values from the sampled x_points using the model equation
schoolfield_model <- ((B0*exp((-E/k)*((1/x_points)-(1/283.15)))) / (1 + (exp((El/k)*((1/Tl)-(1/x_points)))) + (exp((Eh/k)*((1/Th)-(1/x_points))))))
} else{
schoolfield_model <- NA
}
d_f <- data.frame(ID=sfdf[i, "ID"], GR=schoolfield_model)
}
else{
d_f <- data.frame(ID=sfdf[i, "ID"], GR=NA)
}
temp_df <- rbind(temp_df, d_f)
}
return(temp_df)
}
#initialising empty dataframe to append growth rates at temperature = 279.3598 Kelvin
GR_LowTemp <- data.frame(matrix(ncol = 2, nrow = 0))
GR_LowTemp <- rbind(GR_LowTemp, temp_correct(schoolfield_df, 276.15))
x <- c("uniqueID", "LowTemp_GR")
colnames(GR_LowTemp) <- x
#initialising empty dataframe to append growth rates at temperature = 289.15 Kelvin
GR_MidTemp <- data.frame(matrix(ncol = 2, nrow = 0))
GR_MidTemp <- rbind(GR_MidTemp, temp_correct(schoolfield_df, 290))
x <- c("uniqueID", "MidTemp_GR")
colnames(GR_MidTemp) <- x
#initialising empty dataframe to append growth rates at temperature = 310 Kelvin
GR_HighTemp <- data.frame(matrix(ncol = 2, nrow = 0))
GR_HighTemp <- rbind(GR_HighTemp, temp_correct(schoolfield_df, 296.1966))
x <- c("uniqueID", "HighTemp_GR")
colnames(GR_HighTemp) <- x
#Joining only two dataframes together using dplyr
#merged <- inner_join(GR_LowTemp, GR_MidTemp, by='ID')
#Joining more than two dataframes together using dplyr
merged_GR <- inner_join(GR_LowTemp, GR_MidTemp, by='uniqueID') %>%
inner_join(., GR_HighTemp, by='uniqueID')
Average_volumes <- DF[,c("uniqueID","GenusSpecies","AverageVolume","VolumeUnit")]
####### LOG TRANSFORMING THE GROWTH RATES and VOLUMES ########
# Y= Y0.M^a
# ln(Y) = Y0 + a.ln(M) + E
#Merge dataframe on ID to combine data for volume and growth rate
merged_DF <- inner_join(Average_volumes, merged_GR, by='uniqueID')
#Drop repeated IDs
unique_ids <- merged_DF[ !duplicated(merged_DF[ , 1] ) , ]
#averaging growth rates for repeated species to get single data points per species
unique_gr <- unique_ids %>%
group_by(GenusSpecies) %>%
summarise_at(vars("LowTemp_GR", "MidTemp_GR", "HighTemp_GR"), mean, na.rm=T)
View(unique_gr)
View(unique_ids)
View(Average_volumes)
unique_species <- Average_volumes[ !duplicated(Average_volumes[ , 2] ) , ]
View(unique_species)
unique_data <- inner_join(unique_species, unique_gr, by='GenusSpecies')
View(unique_data)
#Subsetting columns which are going to be log-transformed
cols <- c("AverageVolume","LowTemp_GR","MidTemp_GR","HighTemp_GR")
unique_data[cols] <- log10(unique_data[cols])
# Subset columns for different temperatures and removing the NAs
# Low Temp subset
LowTemp <- unique_data[,c("GenusSpecies","AverageVolume","LowTemp_GR")]
View(LowTemp)
LowTemp <- na.omit(LowTemp)
View(LowTemp)
MidTemp <- unique_data[,c("GenusSpecies","AverageVolume","MidTemp_GR")]
MidTemp <- na.omit(MidTemp)
View(MidTemp)
HighTemp <- unique_data[,c("GenusSpecies","AverageVolume","HighTemp_GR")]
HighTemp <- na.omit(HighTemp)
View(HighTemp)
source('~/CMEECoursework/CMEEProject/Code/TempCorrPhytoplankton.r')
source('~/CMEECoursework/CMEEProject/Code/TempCorrBacteria.r')
View(LowTemp)
View(LowTemp)
View(merged_GR)
View(merged_DF)
View(MT)
View(unique_data)
source('~/CMEECoursework/CMEEProject/Code/TempCorrPhytoplankton.r')
View(unique_data)
