}
################################################
# SIMULATE GENETIC DRIFT
# FORWARD IN TIME
# ONE LOCUS, TWO ALLELES
################################################
sim.genetic.drift<-function(p=0.5, t=10, N=50, d=0.6, RO=2, M=10)
{
# DEFINITIONS TO THE INPUT ARGUMENTS
# p IS THE ALLELE FREQ FOR THE FIRST ALLELE (ALLELE 0)
# t IS THE NUMBER OF GENERATIONS
# N IS THE EFFECTIVE POPULATION SIZE
# DEFINE OUTPUTS
# 1) THE ALLELE CONFIG FOR THE ENTIRE POPULATION OVER TIME
# REPORT AS A LIST
population<-list()
length(population)<-t+1
# OPTIONAL, TO GIVE NAMES TO EVERY ELEMENTS OF population
names(population)<-rep(NA, t+1)
for (i in 1:length(population))
{names(population)[i]<-paste(c('generation', i-1), collapse='')}
# 2) I WOULD ALSO LIKE TO RETURN THE ALLELE FREQ OVER TIME
# AS A VECTOR
allele.freq<-rep(NA, t+1)
# TO ASSIGN INITIAL ALLELE COUNTS
k<-ceiling(2*N*p)
population[[1]]<-matrix(sample(c(rep(0, k), rep(1, 2*N-k))), nr=2)
# THE INITIAL ALLELE FREQ
allele.freq[1]<-sum(population[[1]]==0)/(2*N)
# PROPAGATION
#return a list of population showing changes in population size over the generations
#Initialise Nt
for (i in 2:(t+1))
{
#initialise Nt as the new population size at t=0
Nt <- 100
for(i in 2:length(N)){
Nt <- RO*Nt/(1+(Nt/M))
}
df <- data.frame(Time=1:length(Nt), Nt)
# THE ALLELE CONFIG AT THE NEXT GEN
# FIRST WAY OF SAMPLING
population[[i]]<-matrix(sample(0:1, size=2*N, prob=c(allele.freq[i-1], 1-allele.freq[i-1]), replace=TRUE),
nr=2)
# ANOTHER WAY OF SAMPLING
#population[[i]]<-matrix(
#		sample(population[[i-1]], size=2*N, replace=TRUE),
#	nr=2)
# THE ALLELE FREQ AT THE NEXT GEN
allele.freq[i]<-sum(population[[i]]==0)/(2*N)
}
}
#####
# TEST RUN
sim.genetic.drift(p=0.5, t=4, N=10, d=0.6, RO=2, M=10)
#Initialise Nt
#initialise Nt as the new population size at t=0
Nt <- RO*ncol(population[[1]])/(1+(ncol(population[[1]])/M))
rm(list = ls())
################################################
# SIMULATE GENETIC DRIFT
# FORWARD IN TIME
# ONE LOCUS, TWO ALLELES
################################################
sim.genetic.drift<-function(p=0.5, t=10, N=50, d=0.6, RO=2, M=10)
{
# DEFINITIONS TO THE INPUT ARGUMENTS
# p IS THE ALLELE FREQ FOR THE FIRST ALLELE (ALLELE 0)
# t IS THE NUMBER OF GENERATIONS
# N IS THE EFFECTIVE POPULATION SIZE
# DEFINE OUTPUTS
# 1) THE ALLELE CONFIG FOR THE ENTIRE POPULATION OVER TIME
# REPORT AS A LIST
population<-list()
length(population)<-t+1
# OPTIONAL, TO GIVE NAMES TO EVERY ELEMENTS OF population
names(population)<-rep(NA, t+1)
for (i in 1:length(population))
{names(population)[i]<-paste(c('generation', i-1), collapse='')}
# 2) I WOULD ALSO LIKE TO RETURN THE ALLELE FREQ OVER TIME
# AS A VECTOR
allele.freq<-rep(NA, t+1)
# TO ASSIGN INITIAL ALLELE COUNTS
k<-ceiling(2*N*p)
population[[1]]<-matrix(sample(c(rep(0, k), rep(1, 2*N-k))), nr=2) #initial population
# THE INITIAL ALLELE FREQ
allele.freq[1]<-sum(population[[1]]==0)/(2*N)
# PROPAGATION
#return a list of population showing changes in population size over the generations
#Initialise Nt
#initialise Nt as the new population size at t=0
Nt <- RO*ncol(population[[1]])/(1+(ncol(population[[1]])/M))
for (i in 2:(t+1))
{
# THE ALLELE CONFIG AT THE NEXT GEN
# FIRST WAY OF SAMPLING
population[[i]]<-matrix(sample(0:1, size=Nt, prob=c(allele.freq[i-1], 1-allele.freq[i-1]), replace=TRUE),
nr=2)
# ANOTHER WAY OF SAMPLING
#population[[i]]<-matrix(
#		sample(population[[i-1]], size=2*N, replace=TRUE),
#	nr=2)
# THE ALLELE FREQ AT THE NEXT GEN
allele.freq[i]<-sum(population[[i]]==0)/(2*N)
Nt <- RO*ncol(population[[i]])/(1+(ncol(population[[i]])/M))
}
}
# PUT ALL YOUR OUTPUTS INTO ANOTHER LIST AND THEN RETURN THEM
return(list(population=population, allele.freq=allele.freq))
#####
# TEST RUN
sim.genetic.drift(p=0.5, t=4, N=10, d=0.6, RO=2, M=10)
Nt
Nt <- floor(RO*ncol(population[[1]])/(1+(ncol(population[[1]])/M)))
source('~/Documents/Evolutionary_modelling/WF_simulation.r')
################################################
# SIMULATE GENETIC DRIFT
# FORWARD IN TIME
# ONE LOCUS, TWO ALLELES
################################################
sim.genetic.drift<-function(p=0.5, t=10, N=50, d=0.6, RO=2, M=10)
{
# DEFINITIONS TO THE INPUT ARGUMENTS
# p IS THE ALLELE FREQ FOR THE FIRST ALLELE (ALLELE 0)
# t IS THE NUMBER OF GENERATIONS
# N IS THE EFFECTIVE POPULATION SIZE
# DEFINE OUTPUTS
# 1) THE ALLELE CONFIG FOR THE ENTIRE POPULATION OVER TIME
# REPORT AS A LIST
population<-list()
length(population)<-t+1
# OPTIONAL, TO GIVE NAMES TO EVERY ELEMENTS OF population
names(population)<-rep(NA, t+1)
for (i in 1:length(population))
{names(population)[i]<-paste(c('generation', i-1), collapse='')}
# 2) I WOULD ALSO LIKE TO RETURN THE ALLELE FREQ OVER TIME
# AS A VECTOR
allele.freq<-rep(NA, t+1)
# TO ASSIGN INITIAL ALLELE COUNTS
k<-ceiling(2*N*p)
population[[1]]<-matrix(sample(c(rep(0, k), rep(1, 2*N-k))), nr=2) #initial population
# THE INITIAL ALLELE FREQ
allele.freq[1]<-sum(population[[1]]==0)/(2*N)
# PROPAGATION
#return a list of population showing changes in population size over the generations
#Initialise Nt
#initialise Nt as the new population size at t=0
Nt <- floor(RO*ncol(population[[1]])/(1+(ncol(population[[1]])/M)))
for (i in 2:(t+1))
{
# THE ALLELE CONFIG AT THE NEXT GEN
# FIRST WAY OF SAMPLING
population[[i]]<-matrix(sample(0:1, size=Nt, prob=c(allele.freq[i-1], 1-allele.freq[i-1]), replace=TRUE),
nr=2)
# ANOTHER WAY OF SAMPLING
#population[[i]]<-matrix(
#		sample(population[[i-1]], size=2*N, replace=TRUE),
#	nr=2)
# THE ALLELE FREQ AT THE NEXT GEN
allele.freq[i]<-sum(population[[i]]==0)/(2*N)
Nt <- RO*ncol(population[[i]])/(1+(ncol(population[[i]])/M))
}
# PUT ALL YOUR OUTPUTS INTO ANOTHER LIST AND THEN RETURN THEM
return(list(population=population, allele.freq=allele.freq))
}
#####
# TEST RUN
sim.genetic.drift(p=0.5, t=4, N=10, d=0.6, RO=2, M=10)
#####
# TEST RUN
sim.genetic.drift(p=0.5, t=4, N=10, d=0.6, RO=2, M=10)
#####
# TEST RUN
sim.genetic.drift(p=0.5, t=4, N=10, d=0.6, RO=2, M=10)
#####
# TEST RUN
sim.genetic.drift(p=0.5, t=4, N=10, d=0.6, RO=2, M=10)
################################################
# SIMULATE GENETIC DRIFT
# FORWARD IN TIME
# ONE LOCUS, TWO ALLELES
################################################
sim.genetic.drift<-function(p=0.5, t=10, N=50, d=0.6, RO=2, M=10)
{
# DEFINITIONS TO THE INPUT ARGUMENTS
# p IS THE ALLELE FREQ FOR THE FIRST ALLELE (ALLELE 0)
# t IS THE NUMBER OF GENERATIONS
# N IS THE EFFECTIVE POPULATION SIZE
# DEFINE OUTPUTS
# 1) THE ALLELE CONFIG FOR THE ENTIRE POPULATION OVER TIME
# REPORT AS A LIST
population<-list()
length(population)<-t+1
# OPTIONAL, TO GIVE NAMES TO EVERY ELEMENTS OF population
names(population)<-rep(NA, t+1)
for (i in 1:length(population))
{names(population)[i]<-paste(c('generation', i-1), collapse='')}
# 2) I WOULD ALSO LIKE TO RETURN THE ALLELE FREQ OVER TIME
# AS A VECTOR
allele.freq<-rep(NA, t+1)
# TO ASSIGN INITIAL ALLELE COUNTS
k<-ceiling(2*N*p)
population[[1]]<-matrix(sample(c(rep(0, k), rep(1, 2*N-k))), nr=2) #initial population
# THE INITIAL ALLELE FREQ
allele.freq[1]<-sum(population[[1]]==0)/(2*N)
# PROPAGATION
#return a list of population showing changes in population size over the generations
#Initialise Nt
#initialise Nt as the new population size at t=0
Nt <- floor(RO*ncol(population[[1]])/(1+(ncol(population[[1]])/M)))
for (i in 2:(t+1))
{
# THE ALLELE CONFIG AT THE NEXT GEN
# FIRST WAY OF SAMPLING
population[[i]]<-matrix(sample(0:1, size=Nt, prob=c(allele.freq[i-1], 1-allele.freq[i-1]), replace=TRUE),
nr=2)
# ANOTHER WAY OF SAMPLING
#population[[i]]<-matrix(
#		sample(population[[i-1]], size=2*N, replace=TRUE),
#	nr=2)
# THE ALLELE FREQ AT THE NEXT GEN
allele.freq[i]<-sum(population[[i]]==0)/(Nt)
Nt <- RO*ncol(population[[i]])/(1+(ncol(population[[i]])/M))
}
# PUT ALL YOUR OUTPUTS INTO ANOTHER LIST AND THEN RETURN THEM
return(list(population=population, allele.freq=allele.freq))
}
#####
# TEST RUN
sim.genetic.drift(p=0.5, t=4, N=10, d=0.6, RO=2, M=10)
{
# THE ALLELE CONFIG AT THE NEXT GEN
# FIRST WAY OF SAMPLING
population[[i]]<-matrix(sample(0:1, size=2*Nt, prob=c(allele.freq[i-1], 1-allele.freq[i-1]), replace=TRUE),
nr=2)
# ANOTHER WAY OF SAMPLING
#population[[i]]<-matrix(
#		sample(population[[i-1]], size=2*N, replace=TRUE),
#	nr=2)
# THE ALLELE FREQ AT THE NEXT GEN
allele.freq[i]<-sum(population[[i]]==0)/(2*Nt)
Nt <- RO*ncol(population[[i]])/(1+(ncol(population[[i]])/M))
}
################################################
# SIMULATE GENETIC DRIFT
# FORWARD IN TIME
# ONE LOCUS, TWO ALLELES
################################################
sim.genetic.drift<-function(p=0.5, t=10, N=50, d=0.6, RO=2, M=10)
{
# DEFINITIONS TO THE INPUT ARGUMENTS
# p IS THE ALLELE FREQ FOR THE FIRST ALLELE (ALLELE 0)
# t IS THE NUMBER OF GENERATIONS
# N IS THE EFFECTIVE POPULATION SIZE
# DEFINE OUTPUTS
# 1) THE ALLELE CONFIG FOR THE ENTIRE POPULATION OVER TIME
# REPORT AS A LIST
population<-list()
length(population)<-t+1
# OPTIONAL, TO GIVE NAMES TO EVERY ELEMENTS OF population
names(population)<-rep(NA, t+1)
for (i in 1:length(population))
{names(population)[i]<-paste(c('generation', i-1), collapse='')}
# 2) I WOULD ALSO LIKE TO RETURN THE ALLELE FREQ OVER TIME
# AS A VECTOR
allele.freq<-rep(NA, t+1)
# TO ASSIGN INITIAL ALLELE COUNTS
k<-ceiling(2*N*p)
population[[1]]<-matrix(sample(c(rep(0, k), rep(1, 2*N-k))), nr=2) #initial population
# THE INITIAL ALLELE FREQ
allele.freq[1]<-sum(population[[1]]==0)/(2*N)
# PROPAGATION
#return a list of population showing changes in population size over the generations
#Initialise Nt
#initialise Nt as the new population size at t=0
Nt <- floor(RO*ncol(population[[1]])/(1+(ncol(population[[1]])/M)))
for (i in 2:(t+1))
{
# THE ALLELE CONFIG AT THE NEXT GEN
# FIRST WAY OF SAMPLING
population[[i]]<-matrix(sample(0:1, size=2*Nt, prob=c(allele.freq[i-1], 1-allele.freq[i-1]), replace=TRUE),
nr=2)
# ANOTHER WAY OF SAMPLING
#population[[i]]<-matrix(
#		sample(population[[i-1]], size=2*N, replace=TRUE),
#	nr=2)
# THE ALLELE FREQ AT THE NEXT GEN
allele.freq[i]<-sum(population[[i]]==0)/(2*Nt)
Nt <- RO*ncol(population[[i]])/(1+(ncol(population[[i]])/M))
}
# PUT ALL YOUR OUTPUTS INTO ANOTHER LIST AND THEN RETURN THEM
return(list(population=population, allele.freq=allele.freq))
}
#####
# TEST RUN
sim.genetic.drift(p=0.5, t=4, N=10, d=0.6, RO=2, M=10)
k
citation()
getwd()
setwd('CMEECoursework/CMEEProject/Code/')
#!/usr/bin/env Rscript
rm(list=ls())
graphics.off()
require(ggplot2)
library(dplyr)
library(reshape2)
library(scales)
require(gridExtra)
#load in TPC data set to get the x and y co-ordinates per group
df <- read.csv("../Data/bacteria_subset.csv")
DF = df %>% group_by(uniqueID) %>% arrange(uniqueID) #orders the ID in ascending order
View(DF)
#load in the nlls results for the full schoolfield model and plot the results on the same ggplot2 graph
schoolfield_df <- read.csv("../Results/bacteria_schoolfield_params.csv")
View(schoolfield_df)
#!/usr/bin/env Rscript
rm(list=ls())
graphics.off()
require(ggplot2)
library(dplyr)
library(reshape2)
library(scales)
require(gridExtra)
#load in TPC data set to get the x and y co-ordinates per group
df <- read.csv("../Data/bacteria_subset.csv")
DF = df %>% group_by(uniqueID) %>% arrange(uniqueID) #orders the ID in ascending order
#load in the nlls results for the full schoolfield model and plot the results on the same ggplot2 graph
schoolfield_df <- read.csv("../Results/bacteria_schoolfield_params.csv")
source('~/CMEECoursework/CMEEProject/Code/bacteria_scaling_temp.r')
source('~/CMEECoursework/CMEEProject/Code/bacteria_scaling_temp.r')
source('~/CMEECoursework/CMEEProject/Code/archaea_scaling_temp.r')
source('~/CMEECoursework/CMEEProject/Code/archaea_scaling_temp.r')
source('~/CMEECoursework/CMEEProject/Code/phytoplankton_plots.r')
View(DF)
View(df)
View(schoolfield_df)
colMeans(schoolfield_df$Th, na.rm = TRUE)
colMeans(schoolfield_df$Th, na.rm = TRUE)
rowMeans(schoolfield_df$Th, na.rm = TRUE)
colMeans(schoolfield_df$Th, na.rm = TRUE)
schoolfield_df
colMeans(schoolfield_df$Th, na.rm = TRUE)
mean(schoolfield_df$Th)
mean(schoolfield_df$Th, na.rm = TRUE)
2.829125e+02
source('~/CMEECoursework/CMEEProject/Code/bacteria_plots.r')
unique(DF$uniqueID)
pdf("../Results/bacteria.pdf")
for(i in unique(DF$uniqueID)[29:52]){
print(i)
sfdf = subset(schoolfield_df, ID == i)
DF2 = subset(DF, uniqueID == i)
x_vals = DF2$Temp.kel.
y_vals = DF2$StandardisedTraitValue
schoolout <- schoolfield(i, schoolfield_df, DF)
if(!is.null(schoolout)){
x2 = schoolout[1]
y2 = schoolout[2]
}
if(sfdf$status =="C"){
models_plot <- ggplot(DF2, aes(x=x_vals, y=y_vals, colour))+geom_point(color="blue")+
xlab("Temp(kelvin)")+
ylab("Standardised Trait Value")+
ggtitle(paste("Bacteria Model plot for ID:",i))+
theme(plot.title = element_text(hjust = 0.5)) + geom_line(data=schoolfield(i, schoolfield_df, DF), aes(x2, y2, colour="Schoolfield model"))
models_plot <- models_plot + labs(color='Legend')
print(models_plot)
}
}
dev.off()
View(schoolfield_df)
source('~/CMEECoursework/CMEEProject/Code/phytoplankton_plots.r')
View(schoolfield_df)
View(DF2)
View(schoolout)
View(sfdf)
View(phytoplankton_df)
View(schoolout)
schoolout[1]
for(i in unique(DF$uniqueID)[29]){
print(i)
sfdf = subset(schoolfield_df, ID == i)
DF2 = subset(DF, uniqueID == i)
x_vals = DF2$Temp.kel.
y_vals = DF2$StandardisedTraitValue
schoolout <- schoolfield(i, schoolfield_df, DF)
if(!is.null(schoolout)){
x2 = schoolout[2]
y2 = schoolout[3]
}
if(sfdf$status =="C"){
models_plot <- ggplot(DF2, aes(x=x_vals, y=y_vals, colour))+geom_point(color="blue")+
xlab("Temp(kelvin)")+
ylab("Standardised Trait Value")+
ggtitle(paste("Bacteria Model plot for ID:",i))+
theme(plot.title = element_text(hjust = 0.5)) + geom_line(data=schoolfield(i, schoolfield_df, DF), aes(x2, y2, colour="Schoolfield model"))
models_plot <- models_plot + labs(color='Legend')
print(models_plot)
}
}
pdf("../Results/bacteria.pdf")
for(i in unique(DF$uniqueID)[29]){
print(i)
sfdf = subset(schoolfield_df, ID == i)
DF2 = subset(DF, uniqueID == i)
x_vals = DF2$Temp.kel.
y_vals = DF2$StandardisedTraitValue
schoolout <- schoolfield(i, schoolfield_df, DF)
if(!is.null(schoolout)){
x2 = schoolout[2]
y2 = schoolout[3]
}
if(sfdf$status =="C"){
models_plot <- ggplot(DF2, aes(x=x_vals, y=y_vals, colour))+geom_point(color="blue")+
xlab("Temp(kelvin)")+
ylab("Standardised Trait Value")+
ggtitle(paste("Bacteria Model plot for ID:",i))+
theme(plot.title = element_text(hjust = 0.5)) + geom_line(data=schoolfield(i, schoolfield_df, DF), aes(x2, y2, colour="Schoolfield model"))
models_plot <- models_plot + labs(color='Legend')
print(models_plot)
}
}
dev.off()
pdf("../Results/bacteria.pdf")
for(i in unique(DF$uniqueID)[29,53]){
print(i)
sfdf = subset(schoolfield_df, ID == i)
DF2 = subset(DF, uniqueID == i)
x_vals = DF2$Temp.kel.
y_vals = DF2$StandardisedTraitValue
schoolout <- schoolfield(i, schoolfield_df, DF)
if(!is.null(schoolout)){
x2 = schoolout[2]
y2 = schoolout[3]
}
if(sfdf$status =="C"){
models_plot <- ggplot(DF2, aes(x=x_vals, y=y_vals, colour))+geom_point(color="blue")+
xlab("Temp(kelvin)")+
ylab("Standardised Trait Value")+
ggtitle(paste("Bacteria Model plot for ID:",i))+
theme(plot.title = element_text(hjust = 0.5)) + geom_line(data=schoolfield(i, schoolfield_df, DF), aes(x2, y2, colour="Schoolfield model"))
models_plot <- models_plot + labs(color='Legend')
print(models_plot)
}
}
dev.off()
pdf("../Results/bacteria.pdf")
for(i in unique(DF$uniqueID)[52]){
print(i)
sfdf = subset(schoolfield_df, ID == i)
DF2 = subset(DF, uniqueID == i)
x_vals = DF2$Temp.kel.
y_vals = DF2$StandardisedTraitValue
schoolout <- schoolfield(i, schoolfield_df, DF)
if(!is.null(schoolout)){
x2 = schoolout[2]
y2 = schoolout[3]
}
if(sfdf$status =="C"){
models_plot <- ggplot(DF2, aes(x=x_vals, y=y_vals, colour))+geom_point(color="blue")+
xlab("Temp(kelvin)")+
ylab("Standardised Trait Value")+
ggtitle(paste("Bacteria Model plot for ID:",i))+
theme(plot.title = element_text(hjust = 0.5)) + geom_line(data=schoolfield(i, schoolfield_df, DF), aes(x2, y2, colour="Schoolfield model"))
models_plot <- models_plot + labs(color='Legend')
print(models_plot)
}
}
dev.off()
schoolfield(29, schoolfield_df, DF)
View(phytoplankton_df)
# extracting the highest growth rate for each ID and the corresponding temperature
# aggregate
aggregate(phytoplankton_df$schoolfield_model, by = list(phytoplankton_df$ID), max)
phytoplankton_df[ , max("schoolfield_model"), by = ID]
require(data.table) ## 1.9.2
group <- as.data.table(phytoplankton_df)
View(group)
group[group[, .I[schoolfield_model == max(schoolfield_model)], by=ID]$V1]
highest_gr = group[group[, .I[schoolfield_model == max(schoolfield_model)], by=ID]$V1]
View(highest_gr)
mean(highest_gr$x_points)
View(group)
View(highest_gr)
mean(highest_gr$x_points)
source('~/CMEECoursework/CMEEProject/Code/bacteria_plots.r')
source('~/CMEECoursework/CMEEProject/Code/bacteria_plots.r')
?`.I`
?V1
?'V1'
'??V1'
group$V1
View(bacteria_df)
# extracting the highest growth rate for each ID and the corresponding temperature
require(data.table) ## 1.9.2
group <- as.data.table(bacteria_df)
group$V1
View(group)
highest_gr = group[group[, .I[schoolfield_model == max(schoolfield_model)], by=ID]$V1]
View(highest_gr)
mean(highest_gr$x_points)
source('~/CMEECoursework/CMEEProject/Sandbox/codes/archaea_plots.r')
source('~/CMEECoursework/CMEEProject/Sandbox/codes/archaea_plots.r')
source('~/CMEECoursework/CMEEProject/Code/bacteria_plots.r')
source('~/CMEECoursework/CMEEProject/Code/archaea_plots.r')
# extracting the highest growth rate for each ID and the corresponding temperature
require(data.table) ## 1.9.2
View(archaea_df)
group <- as.data.table(archaea_df)
highest_gr = group[group[, .I[schoolfield_model == max(schoolfield_model)], by=ID]$V1]
View(highest_gr)
mean(highest_gr$x_points)
